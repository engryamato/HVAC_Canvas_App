/**
 * Fitting Generation Service
 * 
 * Generates appropriate fitting entities based on detected duct connections
 * and active service rules.
 */
import { Fitting, FittingType } from '@/core/schema';
import { createFitting } from '@/features/canvas/entities/fittingDefaults';
import { createEntity } from '@/core/commands/entityCommands';
import { useEntityStore } from '@/core/store/entityStore';
import { ConnectionDetectionService, DetectedConnection } from './connectionDetection';
import { resolveActiveServiceFromStores } from './componentServiceInterop';

export class FittingGenerationService {
  /**
   * Generate a fitting for a detected connection
   */
  static generateFitting(connection: DetectedConnection): Fitting | null {
    const activeService = resolveActiveServiceFromStores();

    if (!activeService) {
      console.warn('No active service - cannot generate fitting');
      return null;
    }

    // Determine fitting type from connection
    const fittingType = this.mapConnectionToFittingType(connection);
    if (!fittingType) {
      return null;
    }

    // Check if this fitting type is allowed by the service
    const fittingRule = activeService.fittingRules.find((rule) => {
      if (rule.fittingType === fittingType) {
        return true;
      }
      if (fittingType === 'elbow_90' && rule.angle === 90) {
        return true;
      }
      if (fittingType === 'elbow_45' && rule.angle === 45) {
        return true;
      }
      return false;
    });

    if (!fittingRule) {
      console.warn(`Fitting type '${fittingType}' not allowed by service '${activeService.name}'`);
      return null;
    }

    // Calculate fitting position (midpoint of connection)
    const x = connection.newDuct.position.x;
    const y = connection.newDuct.position.y;

    if (this.hasExistingFittingForConnection(connection)) {
      return null;
    }

    // Calculate fitting rotation (average of the two duct angles)
    const rotation = (connection.newDuct.angle + connection.existingDuct.angle) / 2;

    // Create fitting entity
    const fitting = createFitting(fittingType, {
      x,
      y,
      rotation,
      serviceId: activeService.id,
      autoGenerated: true, // Mark as auto-generated
      autoInserted: true,
      angle: connection.angle,
      inletDuctId: connection.existingDuct.entityId,
      outletDuctId: connection.newDuct.entityId,
      connectionPoints: [
        {
          ductId: connection.existingDuct.entityId,
          pointIndex: connection.existingDuct.endPoint === 'start' ? 0 : 1,
        },
        {
          ductId: connection.newDuct.entityId,
          pointIndex: connection.newDuct.endPoint === 'start' ? 0 : 1,
        },
      ],
    });

    return fitting;
  }

  /**
   * Map detected connection to fitting type
   */
  private static mapConnectionToFittingType(
    connection: DetectedConnection
  ): FittingType | null {
    const { fittingType, angle } = connection;

    if (fittingType === 'elbow') {
      // Determine specific elbow type based on angle
      if (angle >= 85 && angle <= 95) {
        return 'elbow_90';
      } else if (angle >= 40 && angle <= 50) {
        return 'elbow_45';
      } else {
        // Custom angle elbow (not yet supported, default to 90)
        return 'elbow_90';
      }
    } else if (fittingType === 'tee') {
      return 'tee';
    }

    return null;
  }

  /**
   * Auto-generate fittings for a newly created duct and create them
   */
  static autoGenerateFittings(newDuctId: string): Fitting[] {
    const connections = ConnectionDetectionService.detectConnections(newDuctId);
    
    const generatedFittings: Fitting[] = [];

    connections.forEach((connection: DetectedConnection) => {
      const fitting = this.generateFitting(connection);
      if (fitting) {
        createEntity(fitting);
        generatedFittings.push(fitting);
      }
    });

    return generatedFittings;
  }

  private static hasExistingFittingForConnection(connection: DetectedConnection): boolean {
    const entities = useEntityStore.getState().byId;

    return Object.values(entities).some((entity) => {
      if (entity.type !== 'fitting') {
        return false;
      }

      const fittingDuctIds = new Set([
        entity.props.inletDuctId,
        entity.props.outletDuctId,
      ]);

      return (
        fittingDuctIds.has(connection.existingDuct.entityId) &&
        fittingDuctIds.has(connection.newDuct.entityId)
      );
    });
  }
}

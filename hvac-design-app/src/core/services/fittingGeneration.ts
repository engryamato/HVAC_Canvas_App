/**
 * Fitting Generation Service
 * 
 * Generates appropriate fitting entities based on detected duct connections
 * and active service rules.
 */
import { Fitting, FittingType } from '@/core/schema';
import { createFitting } from '@/features/canvas/entities/fittingDefaults';
import { createEntity } from '@/core/commands/entityCommands';
import { useServiceStore } from '@/core/store/serviceStore';
import { ConnectionDetectionService, DetectedConnection } from './connectionDetection';

export class FittingGenerationService {
  /**
   * Generate a fitting for a detected connection
   */
  static generateFitting(connection: DetectedConnection): Fitting | null {
    const activeServiceId = useServiceStore.getState().activeServiceId;
    const services = useServiceStore.getState().services;
    const templates = useServiceStore.getState().baselineTemplates;
    const activeService = services[activeServiceId!] || templates.find(t => t.id === activeServiceId);

    if (!activeService) {
      console.warn('No active service - cannot generate fitting');
      return null;
    }

    // Determine fitting type from connection
    const fittingType = this.mapConnectionToFittingType(connection);
    if (!fittingType) {
      return null;
    }

    // Check if this fitting type is allowed by the service
    const fittingRule = activeService.fittingRules.find((rule) => {
      if (rule.fittingType === fittingType) {
        return true;
      }
      if (fittingType === 'elbow_90' && rule.angle === 90) {
        return true;
      }
      if (fittingType === 'elbow_45' && rule.angle === 45) {
        return true;
      }
      return false;
    });

    if (!fittingRule) {
      console.warn(`Fitting type '${fittingType}' not allowed by service '${activeService.name}'`);
      return null;
    }

    // Calculate fitting position (midpoint of connection)
    const x = connection.newDuct.position.x;
    const y = connection.newDuct.position.y;

    // Calculate fitting rotation (average of the two duct angles)
    const rotation = (connection.newDuct.angle + connection.existingDuct.angle) / 2;

    // Create fitting entity
    const fitting = createFitting(fittingType, {
      x,
      y,
      rotation,
      serviceId: activeServiceId || undefined,
      autoGenerated: true, // Mark as auto-generated
      angle: connection.angle,
    });

    return fitting;
  }

  /**
   * Map detected connection to fitting type
   */
  private static mapConnectionToFittingType(
    connection: DetectedConnection
  ): FittingType | null {
    const { fittingType, angle } = connection;

    if (fittingType === 'elbow') {
      // Determine specific elbow type based on angle
      if (angle >= 85 && angle <= 95) {
        return 'elbow_90';
      } else if (angle >= 40 && angle <= 50) {
        return 'elbow_45';
      } else {
        // Custom angle elbow (not yet supported, default to 90)
        return 'elbow_90';
      }
    } else if (fittingType === 'tee') {
      return 'tee';
    }

    return null;
  }

  /**
   * Auto-generate fittings for a newly created duct and create them
   */
  static autoGenerateFittings(newDuctId: string): Fitting[] {
    const connections = ConnectionDetectionService.detectConnections(newDuctId);
    
    const generatedFittings: Fitting[] = [];

    connections.forEach((connection: DetectedConnection) => {
      const fitting = this.generateFitting(connection);
      if (fitting) {
        createEntity(fitting);
        generatedFittings.push(fitting);
      }
    });

    return generatedFittings;
  }
}
